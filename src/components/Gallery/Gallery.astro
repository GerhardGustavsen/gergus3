---
/** RandomGallery.astro */
interface Props {
    /** Either pass images (absolute/processed URLs) OR a glob. */
    images?: string[];
    /** Max rendered width/height per image (px). Default: 360 */
    maxSize?: number;
    /** Delay between dropping each image (ms). Default: 180 */
    delayMs?: number;
    /** Rotation range in degrees. Default: 30 (=> -30..+30) */
    rotationRange?: number;
}

const {
    images = [],
    maxSize = 400,
    delayMs = 50,
    rotationRange = 30,
} = Astro.props;
---

<style>
    /* Container is relative; children are absolutely placed. */
    .windowWidth {
        position: relative;
        width: 100vw;
        margin-left: calc(50% - 50vw);
    }

    #gallery {
        position: relative;

        margin: auto;
        width: 80%;

        height: 1000px;
    }

    .photo {
        position: absolute;
        display: block;
        will-change: transform, left, top;
        transform-origin: 50% 50%;
        max-width: 100%;
        user-select: none;

        border-radius: 0.2em;
        box-shadow: 0 0 8px var(--color-text);
    }
</style>

<div class="windowWidth">
    <div
        id="gallery"
        data-max={maxSize}
        data-delay={delayMs}
        data-rot={rotationRange}
    >
        {
            images.map((u) => (
                <img
                    class="photo"
                    src={u.src}
                    alt="some image"
                    loading="eager"
                    decoding="async"
                />
            ))
        }
    </div>
</div>

<script is:inline>
    // Minimal, no-dependency layout logic.
    // Strategy:
    //  - One-by-one: wait for natural size, compute scale <= maxSize (w/h).
    //  - Pick random X (respecting side margins) and a random rotation (-R..R).
    //  - Y increases as we drop images; we also try to avoid overlaps by bumping X a few times.
    //  - Container height tracks the lowest placed bottom edge.

    const container = document.getElementById("gallery");
    const maxSize = Number(container.dataset.max || 360);
    const delayMs = Number(container.dataset.delay || 180);
    const rotRange = Number(container.dataset.rot || 30);

    const imgs = Array.from(container.querySelectorAll("img"));
    let placed = []; // {x,y,w,h}
    let currentY = 0;
    const baseGapY = maxSize / 30; // vertical spacing baseline
    const triesPerImage = 100;

    const rand = (min, max) => Math.random() * (max - min) + min;

    function overlaps(a, b) {
        // Axis-aligned bounding box; rotation ignored (good enough for small angles)
        return !(
            a.x + a.w <= b.x ||
            b.x + b.w <= a.x ||
            a.y + a.h <= b.y ||
            b.y + b.h <= a.y
        );
    }

    function updateContainerHeight(bottom) {
        // Add some breathing room
        container.style.height = Math.ceil(bottom) + "px";
    }

    function layoutOne(img, yStart) {
        const cw = container.clientWidth;
        const usableW = Math.max(0, cw);

        // natural size
        const nw = img.naturalWidth || 1;
        const nh = img.naturalHeight || 1;

        // scale to fit max width/height
        const scale = Math.min(maxSize / nw, maxSize / nh, 1);
        const w = Math.round(nw * scale);
        const h = Math.round(nh * scale);

        // pick rotation
        const rot = rand(-rotRange, rotRange);

        // start with the Y we’re given
        let yCandidate = yStart;
        let x = 0;
        let ok = false;

        for (let attempt = 0; attempt < triesPerImage; attempt++) {
            const candX = rand(0, Math.max(0, usableW - w));
            const cand = { x: candX, y: yCandidate, w, h };

            ok = true;
            for (const p of placed) {
                if (overlaps(cand, p)) {
                    ok = false;
                    break;
                }
            }

            if (ok) {
                x = candX;
                break;
            } else {
                // didn’t fit: nudge down just a little, then retry with new random X
                yCandidate += maxSize / 10; // small downward step
            }
        }

        if (!ok) {
            // if we still failed, just drop it at the last yCandidate
            x = Math.max(0, Math.min(usableW - w, rand(0, usableW - w)));
        }

        // apply styles
        img.style.width = w + "px";
        img.style.height = h + "px";
        img.style.left = Math.round(x) + "px";
        img.style.top = Math.round(yCandidate) + "px";
        img.style.transform = `rotate(${rot}deg)`;

        placed.push({ x, y: yCandidate, w, h });
        updateContainerHeight(yCandidate + h);

        // return *the same yStart* so next image will try alongside
        return yStart;
    }

    async function placeImagesSequentially() {
        for (let i = 0; i < imgs.length; i++) {
            const img = imgs[i];

            try {
                if (img.decode) await img.decode();
                else
                    await new Promise((res) =>
                        img.complete
                            ? res()
                            : img.addEventListener("load", res, { once: true }),
                    );
            } catch (_) {}

            // Place at the current baseline Y
            layoutOne(img, currentY);

            // Don’t advance Y every time.
            // Instead, after every N images (or when crowded), you can bump it down:
            if ((i + 1) % 3 === 0) {
                // e.g. after 3 tries, move baseline down
                currentY += maxSize / 2; // step down
            }

            if (i < imgs.length - 1) {
                await new Promise((r) => setTimeout(r, delayMs));
            }
        }
    }

    // Re-layout on resize (debounced)
    let rAF = 0,
        lastW = 0;
    function relayout() {
        cancelAnimationFrame(rAF);
        rAF = requestAnimationFrame(() => {
            const cw = container.clientWidth;
            if (Math.abs(cw - lastW) < 2) return;
            lastW = cw;

            // Reset all and re-place
            placed = [];
            currentY = 0;
            container.style.height = "0px";
            for (const img of imgs) {
                // Remove size/pos to let decode give us natural dims again
                img.style.width = "";
                img.style.height = "";
                img.style.left = "-99999px";
                img.style.top = "-99999px";
            }

            // Recompute immediately (no delays on resize to avoid flicker)
            for (const img of imgs) {
                layoutOne(img, currentY);
                currentY +=
                    Math.max(16, img.clientHeight * 0.55) +
                    baseGapY +
                    rand(-6, 12);
            }
        });
    }

    // Initial invisible positioning: keep off-screen until placed
    for (const img of imgs) {
        img.style.left = "-99999px";
        img.style.top = "-99999px";
    }

    placeImagesSequentially();
    window.addEventListener("resize", () => relayout(), { passive: true });
</script>
